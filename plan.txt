Personal note from Eric:

This project was the first time I've ever been paid to program, at the time of this writing it is the biggest project
I've ever worked on, and was mostly completed just after my 2nd year of university with minimal supervision.
This project has changed forms many times, includes some little bits of features that I thought about implementing but
later decided not to, there are some elements in the structure that don't really make sense with the way things are
currently laid out but made sense back when they were first written, there are some elements of the structure that
didn't even really make sense when I first wrote them.

In hindsight, there's a lot of things I would have done differently (most notably, just thinking things through better
before starting to write code), and some of the code in here is definitely not my best work. I've done a little bit of
work to clean things up, and I've documented everything to the best of my ability. The rest of this document contains
information about the structure and design of this software.

Do not hesitate to contact me at err291@mail.usask.ca if you have any questions about this code, or if you'd just like
to berate me for being bad at programming when I wrote this.


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Overview:

MODULES

    Control: Core classes for the model-view-controller
        - these classes do pretty much all the work for everything except for actually playing the tones and storing the
          results on disk
    HearingTest: contains all classes specific to hearing tests
        - Container: classes that store the results of one or more hearing tests, or information regarding the events
          that occurred during a hearing test (eg. Click, SingleTrialResult)
        - Confidence/Ramp/Reduce: classes for the specific types of tests. See below for details
            - these classes are the ones that play the tones and store the results
        - Tone: classes that represent a particular type of tone (eg. 2-pitch interval, melody, sine wave, .wav file)
    Others: Miscellaneous - mainly the activities and views

HEARING TESTS

This application is all about performing hearing tests on participants. "Hearing Test" is the generic name given to any
test that plays tones and tests a participant's ability to correctly identify or hear those tones. The abstract class
from which all hearing tests inherit is called HearingTest. All hearing tests are contained within the HearingTest
module.

At the next level, there are two types of hearing tests: Calibration and Confidence. A calibration test can either be a
single test or a suite of tests designed to generate a model that can predict whether the participant will be able to
hear a different tone not necessarily tested in the calibration test. A confidence test performs more trials on fewer
tones to find the "true" probability that the user will hear those tones, and then compares the probability found to the
probabilities generated by any models previously generated by calibration tests for that participant

Calibration tests include the "ramp test", which starts a tone quietly then slowly increases the volume until the user
indicates that they can hear the tone; the "reduce test" which takes the volumes found by the ramp test and slowly
reduces the volumes until the user indicates that they can't hear it anymore; and the "calibration test" (see confusion
alert below) which tests several tones a few times each to try to get a somewhat-accurate picture of the "true" sigmoid
graph for the participant's probability of hearing those tones. A "3-phase calibration" is a ramp, reduce, and
calibration test back-to-back. When information from previous tests in the suite is not available to set up for a future
test, it is inferred whenever possible, or taken from a previous test suite. The goal is to make the ramp test powerful
enough to obviate the need for the much longer and more painful 3-phase calibration.

Confidence tests simply choose a few tones to test and run several trials on each of them to try to find a "true" value
for the probability of the participant hearing that tone. The results of a confidence test are used to test the accuracy
of the models generated by previously-run calibration tests, and to test their predictive power on different types of
tones. For example. the confidence test suites generally only test single-pitch sine waves, but the confidence test can
check that calibration's ability to predict the user's probability of hearing a .wav "earcon" or a melody of sine waves.

The CalibrationTest, ReduceTest, and RampTest all already have their run() methods implemented in the abstract class. A
particular subclass need only implement the playTone() method which plays the particular type of tone to be tested.


POTENTIAL CONFUSION ALERT

Due to the way this project evolved over time and my unfortunate lack of foresight, there are two meanings of the
phrase "Calibration Test" in this project. The first and most common usage is to mean the specific hearing test in
which participants are tested on the same tones multiple times each at various volumes. The other is to indicate any
suite of hearing tests which produces results that can be used to predict whether a participant will be able to hear a
particular tone. It should be clear from the context and/or comments which is being used. If you are reading this, it's
because I've decided that it's not worth my time to go through the project and rename one of them to make it more
readable for future programmers. Sorry, future programmer :( unless you are Eric, in which case I'm not sorry and you
only have yourself (ie. me) to blame

Eg. in HearingTestController, the function "calibrationTest" begins a test or suite of tests that may or may not contain
a "calibration test", but the private methods setupCalibrationTest and calibrationTestComplete pertain specifically to
the individual multi-tone test described in the first definition in the previous paragraph.

##############################

PARTICIPANTS / FILE IO

A "participant" is an individual person who has taken or will take hearing tests with this application. A participant is
assigned a directory on whichever device this application is being run on when they are first logged in. In that
directory is a single "calibration file" in which the participant's Calibration Test results are stored. A line is
saved in that file for every tone that is played in the test, containing information about the tone and the user's
response to it. A line is saved before and after the test to indicate the beginning and end of the test. Ramp, Reduce,
and Calibration tests are saved as separate tests. At login time, data is loaded from this calibration file into a
Participant object which will be used until the user switches participants or exits the application. Each confidence
test is saved in an individual file in the user's directory, and contains human-readable statistical data at the end of
the file.

For more information, see "files" below

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Running tests:

Each subclass of the abstract HearingTest class must have a run() method, which plays tones via the Model and tracks the
results in a stored HearingTestResults object (or not, in the case of a ReduceTest. See "Storing Results At Runtime"
below). The run() method is called from HearingTestController.checkForHearingTestResume() - never called directly from
setup*Test() or any other method. All tests are started by setting them in the HearingTestInteractionModel and calling
checkForHearingTestResume (or causing it to be called indirectly). The following is a more detailed description of the
control flow while starting a new test:

Calibration:
    Register "calibration" click in MainActivity
    Go to CalibSelectActivity, return with integer IDs for all selected options
        - or just end here if user cancelled in CalibSelectActivity screen
    Return to MainActivity, and pass the selected IDs to HearingTestController.calibrationTest()
    Select the appropriate test types and put into the HearingTestInteractionModel
        - 1 to 3, depending on user's selection. Set as fields in the iModel so we know which tests to run later on
        - set the first test as iModel.currentTest
        - null any tests that are not going to be run
    Set the test to paused, show the test information in a dialog to the user, then notifySubscribers() when done.
        - This causes MainActivity to call HearingTestController.checkForHearingTestResume(), which starts whichever
          test was put on deck by HearingTestController.calibrationTest() to begin
    Once the first test is complete, control is passed to to HearingTestController.*TestComplete, which saves the
        results of the test and starts the next test, if there is one
    If a user pauses during a test, execution hangs until the user un-pauses, at which time notifySubscribers() is
        called and the test is resumed as described above

    Note: multi-test suites are always executed in the following order: Ramp -> reduce -> calibration
        - because later tests depend on information from previous ones.
        - information may be taken from a previous test suite with the same noise type and volume, if needed
            - unless it's a reduce test. Reduce tests must immediately follow a ramp test

Confidence:
    Basically the same as calibration except there is only 1 test to be run, and there are more options for timbres and
    types, and we get options from user in ConfSelectActivity


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Storing test results at runtime:

The following explanation is for how hearing test results are stored in memory at runtime. Persistent storage is
explained under "files", and briefly under "Participants"

Hearing test results are stored in a special container class, found in the HearingTest.Container module. A
meta-container for storing the results of many hearing tests is provided by the HearingTestResultsCollection class. Each
Participant has an associated HearingTestResultsCollection in which all of their tests taken to date (either performed
recently, or read from a file at load time) are stored.

The results of an individual hearing test are stored in an object inheriting from the HearingTestResults abstract class.
One notable child of the HearingTestResults class is the PredictorResults abstract class, which contains the results of
any hearing test whose results can be used to make predictions about tones not necessarily performed in the test itself
(ie. CalibrationTest and RampTest)

RampTestResults

    The RampTestResults class is not often used, except to indicate that a test was only a ramp test and no reduce test
    was performed. While performing a RampTest, the results are stored into a RampTestResultsWithFloorInfo class, which
    inherits from RampTestResults but also has fields in which to store the results of a reduce test. After performing a
    RampTest, we store the results into a HearingTestResultsCollection as RampTestResults using
    RampTesResultsWithFloorInfo.getRegularRampResults().

    After performing a ReduceTest (which necessarily must be performed immediately following a RampTest), we find the
    results of the previously-performed RampTest, then store the ReduceTestResults (in the form of an array of
    FreqVolPairs, rather than its own Results object) into the RampTestResultsWithFloorInfo from the last test using
    the setReduceResults() method, then add the RampTestResultsWithFloorInfo directly to the
    HearingTestResultsCollection without modifying it. Internally, the RampTest class uses a RampTestResults class. This
    is mostly a legacy thing and doesn't serve any purpose outside of the internals of the class itself. To load the
    results of a ReduceTest from a file, use the ReduceTest.ResultsBuilder class, add the results with addResult(),
    then call builder.build().getResults() to get the results in a form suitable for adding to a
    RampTestResultsWithFloorInfo.


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Login screen:

    New Participant
        - Use ID in text box
        - Disallow duplicate participants
    Load Participant
        - Use ID in text box
        - If noticed a half-finished test, ask to resume (in case of crashes)
            - (not yet implemented)
    Skip This Step
        - Login with default user (ID 0)

The login screen returns to the main activity with only a participant ID. Participant files are guaranteed to exist when
control returns to the main activity - if creating a new participant, empty files are created by the login screen before
returning. Files are loaded via the FileIOController from MainActivity after returning

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Files:

Individual participant files are kept in one folder per participant, which contains a single calibration file containing
information about all calibrations taken by this participant, and one file per confidence test

Calibration result file (one per participant):
    Named Calibration_N where N is the participant number

    START-TEST <DATE> <TEST-TYPE> <NOISE>
    <TIME> <FREQ> <VOL> <DIRECTION> <CORRECT?> <NUM-CLICKS> <CLICK-STRING>
    ...
    END-TEST

    A ramp test contains 2 lines per frequency: one for each ramp-up


Confidence result file (one per test):
    Named Confidence_DATE_N where DATE is the current date/time and N is the participant number

    START-TEST <TEST-TYPE> <NOISE> <DATE>
    <TIME> <FREQ> <VOL> <DIRECTION> <CORRECT?> <NUM-CLICKS> <CLICK-STRING>
    ...
    END-TEST

    ResultsAsString, like in the previous version
    Other metadata and stats
