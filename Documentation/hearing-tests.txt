Information about the hearing tests available in this application and their implementations

################################################# About Hearing Tests ##################################################

This application is all about performing hearing tests on participants. "Hearing Test" is the generic name given to any
test that plays tones and tests a participant's ability to correctly identify or hear those tones. The abstract class
from which all hearing tests inherit is called HearingTest. All hearing tests are contained within the HearingTest
module.

At the next level, there are two types of hearing tests: Calibration and Confidence. A calibration test can either be a
single test or a suite of tests designed to generate a model that can predict whether the participant will be able to
hear a different tone not necessarily tested in the calibration test. A confidence test performs more trials on fewer
tones to find the "true" probability that the user will hear those tones, and then compares the probability found to the
probabilities generated by any models previously generated by calibration tests for that participant

Calibration tests include the "ramp test", which starts a tone quietly then slowly increases the volume until the user
indicates that they can hear the tone; the "reduce test" which takes the volumes found by the ramp test and slowly
reduces the volumes until the user indicates that they can't hear it anymore; and the "calibration test" (see confusion
alert below) which tests several tones a few times each to try to get a somewhat-accurate picture of the "true" sigmoid
graph for the participant's probability of hearing those tones. A "3-phase calibration" is a ramp, reduce, and
calibration test back-to-back. When information from previous tests in the suite is not available to set up for a future
test, it is inferred whenever possible, or taken from a previous test suite. The goal is to make the ramp test powerful
enough to obviate the need for the much longer and more painful 3-phase calibration.

Confidence tests simply choose a few tones to test and run several trials on each of them to try to find a "true" value
for the probability of the participant hearing that tone. The results of a confidence test are used to test the accuracy
of the models generated by previously-run calibration tests, and to test their predictive power on different types of
tones. For example. the confidence test suites generally only test single-pitch sine waves, but the confidence test can
check that calibration's ability to predict the user's probability of hearing a .wav "earcon" or a melody of sine waves.

The Calibration Test extends the SingleToneTest, meaning that the Calibration Test is only meant to test users on their
ability to hear a single tone (a sine wave, a single .wav earcon, but not an interval or melody). Early versions of this
project did include calibration tests that used intervals and/or melodies, but these were removed during one of this
project's many redesigns because the ramp test only tests single tones and we want to use the ramp test in the end
anyway. If for some reason you must perform calibrations with intervals, you can make a different subclass of
HearingTest, or maybe even just make CalibrationTest not inherit from SingleToneTest anymore because I'm not entirely
convinced that that class still makes sense with the current state of things. The ConfidenceTest can test any sort of
tone - we use this to test the predictive power of the Calibration and/or Ramp tests on tones that they did not test,
for example testing how well participants could distinguish melodies of sine waves based on their ramp test scores.

The CalibrationTest, ReduceTest, and RampTest all already have their run() methods implemented in the abstract class. A
particular subclass need only implement the playTone() method which plays the particular type of tone to be tested.


POTENTIAL CONFUSION ALERT

Due to the way this project evolved over time and my unfortunate lack of foresight, there are two meanings of the
phrase "Calibration Test" in this project. The first and most common usage is to mean the specific hearing test in
which participants are tested on the same tones multiple times each at various volumes. The other is to indicate any
suite of hearing tests which produces results that can be used to predict whether a participant will be able to hear a
particular tone. It should be clear from the context and/or comments which is being used. If you are reading this, it's
because I've decided that it's not worth my time to go through the project and rename one of them to make it more
readable for future programmers. Sorry, future programmer :( unless you are Eric, in which case I'm not sorry and you
only have yourself (ie. me) to blame

Eg. in HearingTestController, the function "calibrationTest" begins a test or suite of tests that may or may not contain
a "calibration test", but the private methods setupCalibrationTest and calibrationTestComplete pertain specifically to
the individual multi-tone test described in the first definition in the previous paragraph.


################################################ Running a Hearing Test ################################################

Each subclass of the abstract HearingTest class must have a run() method, which plays tones via the Model and tracks the
results in a stored HearingTestResults object (or not, in the case of a ReduceTest. See "Storing Results At Runtime"
below). The run() method is called from HearingTestController.checkForHearingTestResume() - never called directly from
setup*Test() or any other method. All tests are started by setting them in the HearingTestInteractionModel and calling
checkForHearingTestResume (or causing it to be called indirectly). The following is a more detailed description of the
control flow while starting a new test:

Calibration:
    Register "calibration" click in MainActivity
    Go to CalibSelectActivity, return with integer IDs for all selected options
        - or just end here if user cancelled in CalibSelectActivity screen
    Return to MainActivity, and pass the selected IDs to HearingTestController.calibrationTest()
    Select the appropriate test types and put into the HearingTestInteractionModel
        - 1 to 3, depending on user's selection. Set as fields in the iModel so we know which tests to run later on
        - set the first test as iModel.currentTest
        - null any tests that are not going to be run
    Set the test to paused, show the test information in a dialog to the user, then notifySubscribers() when done.
        - This causes MainActivity to call HearingTestController.checkForHearingTestResume(), which starts whichever
          test was put on deck by HearingTestController.calibrationTest() to begin
    Once the first test is complete, control is passed to to HearingTestController.*TestComplete, which saves the
        results of the test and starts the next test, if there is one
    If a user pauses during a test, execution hangs until the user un-pauses, at which time notifySubscribers() is
        called and the test is resumed as described above

    Note: multi-test suites are always executed in the following order: Ramp -> reduce -> calibration
        - because later tests depend on information from previous ones.
        - information may be taken from a previous test suite with the same noise type and volume, if needed
            - unless it's a reduce test. Reduce tests must immediately follow a ramp test

Confidence:
    Basically the same as calibration except there is only 1 test to be run, and there are more options for timbres and
    types, and we get options from user in ConfSelectActivity